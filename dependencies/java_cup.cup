import java_cup.runtime.*;

parser code {:
  Lexer lexer;

  public parser(Lexer lexer) {
    this.lexer = lexer;
  } 
  
  public void report_error(String message, Object info) {
       
            StringBuilder m = new StringBuilder("Error");
       
            if (info instanceof java_cup.runtime.Symbol) {
                java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
       
                if (s.left >= 0) {                
                    m.append(" in line "+(s.left+1));   
                    if (s.right >= 0)                    
                        m.append(", column "+(s.right+1));
                }
            }
       
            m.append(" : "+message);
       
            System.err.println(m);
        }
       
      public void report_fatal_error(String message, Object info) {
          report_error(message, info);
          System.exit(1);

		}
:}

/* define how to connect to the scanner! */
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, 
                    PLUS,
                    DOT,
                    COMMA, 
                    MINUS, 
                    TIMES, 
                    DIVIDE,
                    OR_ASSIGN, 
                    MOD, 
                    LPAREN, 
                    RPAREN,
                    LBRACK,
                    RBRACK,
                    L_BRACE,
                    R_BRACE,
                    NOT,
                    EQ,
                    LT,
                    RT,
                    AUTO,
                    BREAK,
                    CHAR,
                    CONST,
                    CONTINUE,
                    DEFAULT,
                    DO,
                    DOUBLE,
                    ELSE,
                    ENUM,
                    EXTERN,
                    FLOAT,
                    FOR,
                    GOTO,
                    INT,
                    COMMENT,
                    LONG,
                    REGISTER,
                    RETURN,
                    SHORT,
                    SIGNED,
                    SIZEOF,
                    STATIC,
                    STRUCT,
                    SWITCH,
                    UNION,
                    UNSIGNED,
                    VOID,
                    VOLATILE,
                    WHILE,
                    CONSTANT,
                    ELLIPSIS,
                    RIGHT_ASSIGN,
                    LEFT_ASSIGN,
                    ADD_ASSIGN,
                    SUB_ASSIGN,
                    EMUL_ASSIGN,
                    DIV_ASSIGN,
                    MOD_ASSIGN,
                    AND_ASSIGN,
                    XOR_ASSIGN,
                    RIGHT_OP,
                    LEFT_OP,
                    INC_OP,
                    DEC_OP,
                    PTR_OP,
                    AND_OP,
                    OR_OP,
                    LE_OP,
                    GE_OP,
                    EQ_OP,
                    MUL_ASSIGN,
                    IF,
                    NEWLINE,
                    IDENTIFIER,
                    LIBRARY,
                    STRING,
                    INT_CONST,
                    STRING_CONST,
                    DOUBLE_CONST,
                    NE_OP,
                    TYPEDEF,
                    CASE,
                    COLON,
                    XOR,
                    OR,
                    QUESTION
                    
;

/* Non terminals */
non terminal            primary_expression,
                        postfix_expression,
                        abstract_declarator,
                        argument_expression_list,
                        unary_operator,
                        unary_expression,
                        cast_expression,
                        multiplicative_expression,
                        additive_expression,
                        shift_expression,
                        relational_expression,
                        equality_expression,
                        and_expression,
                        exclusive_or_expression,
                        inclusive_or_expression,
                        logical_and_expression,
                        logical_or_expression,
                        conditional_expression,
                        assignment_expression,
                        assignment_operator,
                        expression,
                        constant_expression,
                        declaration,
                        declaration_specifiers,
                        init_declarator_list,
                        init_declarator,
                        storage_class_specifier,
                        type_specifier,
                        struct_or_union_specifier,
                        struct_or_union,
                        struct_declaration_list,
                        struct_declaration,
                        specifier_qualifier_list,
                        struct_declarator_list,
                        struct_declarator,
                        enum_specifier,
                        enumerator_list,
                        enumerator,
                        type_qualifier,
                        declarator,
                        direct_declarator,
                        pointer,
                        type_qualifier_list,
                        parameter_type_list,
                        parameter_list,
                        parameter_declaration,
                        identifier_list,
                        type_name,
                        initializer,
                        statement,
                        labeled_statement,
                        direct_abstract_declarator,
                        compound_statement,
                        declaration_list,
                        statement_list,
                        selection_statement,
                        iteration_statement,
                        jump_statement,
                        translation_unit,
                        external_declaration,
                        function_definition,
                        initializer_list,
                        expression_statement
;

/* Precedences 
   Bottom is highest*/
precedence left OR_OP;
precedence left AND_OP;
precedence left EQ_OP;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left NOT;
precedence left LPAREN;
precedence left LBRACK;
precedence left L_BRACE;

start with translation_unit;

primary_expression::= IDENTIFIER
	| CONSTANT
	| LPAREN expression RPAREN
	;

postfix_expression::= primary_expression
	| postfix_expression LBRACK expression LBRACK
	| postfix_expression LPAREN RPAREN
	| postfix_expression LPAREN argument_expression_list RPAREN
	| postfix_expression DOT IDENTIFIER
	| postfix_expression PTR_OP IDENTIFIER
	| postfix_expression INC_OP
	| postfix_expression DEC_OP
	;

argument_expression_list::= assignment_expression
	| argument_expression_list COMMA assignment_expression
	;

unary_expression::= postfix_expression
	| INC_OP unary_expression
	| DEC_OP unary_expression
	| unary_operator cast_expression
	;

unary_operator::= AND_OP
	| TIMES
	| PLUS
	| MINUS
	| NOT
	;

cast_expression::= unary_expression
	| LPAREN type_name RPAREN cast_expression
	;

multiplicative_expression::= cast_expression
	| multiplicative_expression TIMES cast_expression
	| multiplicative_expression DIVIDE cast_expression
	| multiplicative_expression MOD cast_expression
	;

additive_expression::= multiplicative_expression
	| additive_expression PLUS multiplicative_expression
	| additive_expression MINUS multiplicative_expression
	;

shift_expression::= additive_expression
	| shift_expression LEFT_OP additive_expression
	| shift_expression RIGHT_OP additive_expression
	;

relational_expression::= shift_expression
	| relational_expression LT shift_expression
	| relational_expression RT shift_expression
	| relational_expression LE_OP shift_expression
	| relational_expression GE_OP shift_expression
	;

equality_expression::= relational_expression
	| equality_expression EQ_OP relational_expression
	| equality_expression NE_OP relational_expression
	;

and_expression::= equality_expression
	| and_expression AND_OP equality_expression
	;

exclusive_or_expression::= and_expression
	| exclusive_or_expression XOR and_expression
	;

inclusive_or_expression::= exclusive_or_expression
	| inclusive_or_expression OR exclusive_or_expression
	;

logical_and_expression::= inclusive_or_expression
	| logical_and_expression AND_OP inclusive_or_expression
	;

logical_or_expression::= logical_and_expression
	| logical_or_expression OR_OP logical_and_expression
	;

conditional_expression::= logical_or_expression
	| logical_or_expression QUESTION expression COLON conditional_expression
	;

assignment_expression::= conditional_expression
	| unary_expression assignment_operator assignment_expression
	;

assignment_operator::= EQ
	| EMUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

expression::= assignment_expression
	| expression COMMA assignment_expression
	;

constant_expression::= conditional_expression
	;

declaration::= declaration_specifiers SEMI
	| declaration_specifiers init_declarator_list SEMI
	;

declaration_specifiers::= storage_class_specifier
	| storage_class_specifier declaration_specifiers
	| type_specifier
	| type_specifier declaration_specifiers
	| type_qualifier
	| type_qualifier declaration_specifiers
	;

init_declarator_list::= init_declarator
	| init_declarator_list COMMA init_declarator
	;

init_declarator::= declarator
	| declarator EQ initializer
	;

storage_class_specifier::= STATIC
	| AUTO
	| REGISTER
	;

type_specifier::= VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	| struct_or_union_specifier
	| enum_specifier
	;

struct_or_union_specifier::= struct_or_union IDENTIFIER L_BRACE struct_declaration_list R_BRACE
	| struct_or_union L_BRACE struct_declaration_list R_BRACE
	| struct_or_union IDENTIFIER
	;

struct_or_union::= STRUCT
	| UNION
	;

struct_declaration_list::= struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration::= specifier_qualifier_list struct_declarator_list SEMI
	;

specifier_qualifier_list::= type_specifier specifier_qualifier_list
	| type_specifier
	| type_qualifier specifier_qualifier_list
	| type_qualifier
	;

struct_declarator_list::= struct_declarator
	| struct_declarator_list COMMA struct_declarator
	;

struct_declarator::= declarator
	| COLON constant_expression
	| declarator COLON constant_expression
	;

enum_specifier::= ENUM L_BRACE enumerator_list R_BRACE
	| ENUM IDENTIFIER L_BRACE enumerator_list R_BRACE
	| ENUM IDENTIFIER
	;

enumerator_list::= enumerator
	| enumerator_list COMMA enumerator
	;

enumerator::= IDENTIFIER
	| IDENTIFIER EQ constant_expression
	;

type_qualifier::= CONST
	;

declarator::= pointer direct_declarator
	| direct_declarator
	;

direct_declarator::= IDENTIFIER
	| LPAREN declarator RPAREN
	| direct_declarator LBRACK constant_expression RBRACK
	| direct_declarator LBRACK RBRACK
	| direct_declarator LPAREN parameter_type_list RPAREN
	| direct_declarator LPAREN identifier_list RPAREN
	| direct_declarator LPAREN RPAREN
	;

pointer::= TIMES
	| TIMES type_qualifier_list
	| TIMES pointer
	| TIMES type_qualifier_list pointer
	;

type_qualifier_list::= type_qualifier
	| type_qualifier_list type_qualifier
	;


parameter_type_list::= parameter_list
	| parameter_list COMMA ELLIPSIS
	;

parameter_list::= parameter_declaration
	| parameter_list COMMA parameter_declaration
	;

parameter_declaration::= declaration_specifiers declarator
	| declaration_specifiers abstract_declarator
	| declaration_specifiers
	;

identifier_list::= IDENTIFIER
	| identifier_list COMMA IDENTIFIER
	;

type_name::= specifier_qualifier_list
	| specifier_qualifier_list abstract_declarator
	;

abstract_declarator::= pointer
	| direct_abstract_declarator
	| pointer direct_abstract_declarator
	;

direct_abstract_declarator::= LPAREN abstract_declarator RPAREN
	| LBRACK RBRACK
	| LBRACK constant_expression RBRACK
	| direct_abstract_declarator LBRACK RBRACK
	| direct_abstract_declarator LBRACK constant_expression RBRACK
	| LPAREN RPAREN
	| LPAREN parameter_type_list RPAREN
	| direct_abstract_declarator LPAREN RPAREN
	| direct_abstract_declarator LPAREN parameter_type_list RPAREN
	;

initializer::= assignment_expression
	| L_BRACE initializer_list R_BRACE
	| L_BRACE initializer_list COMMA R_BRACE
	;

initializer_list::= initializer
	| initializer_list COMMA initializer
	;

statement::= labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;

labeled_statement::= IDENTIFIER COLON statement
	| CASE constant_expression COLON statement
	| DEFAULT COLON statement
	;

compound_statement::= L_BRACE R_BRACE
	| L_BRACE statement_list R_BRACE
	| L_BRACE declaration_list R_BRACE
	| L_BRACE declaration_list statement_list R_BRACE
	;

declaration_list::= declaration
	| declaration_list declaration
	;

statement_list::= statement
	| statement_list statement
	;

expression_statement::= SEMI
	| expression SEMI
	;

selection_statement::= IF LPAREN expression RPAREN statement;

iteration_statement::= WHILE LPAREN expression RPAREN statement
	| DO statement WHILE LPAREN expression RPAREN SEMI
	| FOR LPAREN expression_statement expression_statement RPAREN statement
	| FOR LPAREN expression_statement expression_statement expression RPAREN statement
	;

jump_statement::= GOTO IDENTIFIER SEMI
	| CONTINUE SEMI
	| BREAK SEMI
	| RETURN SEMI
	| RETURN expression SEMI
	;

translation_unit::= external_declaration
	| translation_unit external_declaration
	;

external_declaration::= function_definition
	| declaration
	;

function_definition::= declaration_specifiers declarator declaration_list compound_statement
	| declaration_specifiers declarator compound_statement
	| declarator declaration_list compound_statement
	| declarator compound_statement
	;
